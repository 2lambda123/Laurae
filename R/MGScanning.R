#' Multi-Grained Scanning implementation in R
#'
#' This function attempts to replicate Multi-Grained Scanning using xgboost. It performs Random Forest \code{n_forest} times using \code{n_trees} trees on your data using a sliding window to create features. You can specify your learning objective using \code{objective} and the metric to check for using \code{eval_metric}. You can plug custom objectives instead of the objectives provided by \code{xgboost}.
#' 
#' For implementation details of Cascade Forest / Complete-Random Tree Forest / Multi-Grained Scanning / Deep Forest, check this: \url{https://github.com/Microsoft/LightGBM/issues/331#issuecomment-283942390} by Laurae.
#' 
#' \itemize{
#' \item{Complete-Random Tree Forest = ensemble of Random Trees (number of forests parameter)}
#' \item{Random Tree split = take a random feature each time, grow indefinitely until there are only no more than 10 instances of the same class (or there is only one class at the end) (minimum number of instances parameter)}
#' \item{Random Tree Forest = take only sqrt(number of features) per tree (column sampling by tree parameter)}
#' \item{(NOT IMPLEMENTED AS IT IS XGBOOST USED) Split value used = Gini (but I would say using Information Criterion could be better for random forests) (potentially loss function parameter)}
#' \item{Number of features generated by a level = number of complete-random tree forest * number of classes, in case of regression this would be number of complete-random tree forest}
#' \item{Each Complete-Random Tree Forest is generated using cross-validation (stacking like in Kaggle competitions) and using average when you predict (parameter - input folds)}
#' \item{Each time a Cascade Forest is finished, compare to validation set. If the new Cascade Forest is worse than the previous one, terminate training immediately (bonus: early_stopping_rounds would be able to determine how many bad Cascade Forest needed to stop, and maybe prediction should give us the ability to choose how many forests to use?).}
#' }
#' 
#' @param data Type: data.table (\code{dimensions == 1}) or list of matrices (\code{dimensions == 2}). The training data.
#' @param labels Type: numeric vector. The training labels.
#' @param folds Type: list. The folds as list for cross-validation.
#' @param dimensions Type: numeric. The dimensions of the data. Only supported is \code{1} for matrix format, and \code{2} for list of matrices. Defaults to \code{1}.
#' @param depth Type: numeric. The size of the sliding window applied. Use a vector of size 2 when using two dimensions (row, col). Do not make it larger than \code{ncol(data)} when \code{dimensions == 1}, or when \code{dimensions == 2} the \code{depth} must be smaller than the height and width of each matrix. Defaults to \code{2}.
#' @param stride Type: numeric. The stride (sliding steps) applied to each sliding window. Use a vector of size 2 when using two dimensions (row, col). Defaults to \code{1}.
#' @param nthread Type: numeric. The number of threads using for multithreading. 1 means singlethread (uses only one core). Higher may mean faster training if the memory overhead is not too large. Defaults to \code{1}.
#' @param lr Type: numeric. The shrinkage affected to each tree to avoid overfitting. Defaults to \code{1}, which means no adjustment.
#' @param training_start Type: numeric vector. The initial training prediction labels. Set to \code{NULL} if you do not know what you are doing. Defaults to \code{NULL}.
#' @param validation_start Type: numeric vector. The initial validation prediction labels. Set to \code{NULL} if you do not know what you are doing. Defaults to \code{NULL}.
#' @param n_forest Type: numeric. The number of forest models to create for the Complete-Random Tree Forest. Defaults to \code{5}.
#' @param n_trees Type: numeric. The number of trees per forest model to create for the Complete-Random Tree Forest. Defaults to \code{1000}.
#' @param random_forest Type: numeric. The number of Random Forest in the forest. Defaults to \code{0}.
#' @param seed Type: numeric. Random seed for reproducibility. Defaults to \code{0}.
#' @param objective Type: character or function. The function which leads \code{boosting} loss. See \code{xgboost::xgb.train}. Defaults to \code{"reg:linear"}.
#' @param eval_metric Type: character or function. The function which evaluates \code{boosting} loss. See \code{xgboost::xgb.train}. Defaults to \code{"rmse"}.
#' @param multi_class Type: logical. Defines internally whether you are doing multi class classification or not to use specific routines for multiclass problems when using \code{return_list == FALSE}. Defaults to \code{FALSE}.
#' @param verbose Type: character. Whether to print for training evaluation. Use \code{""} for no printing (double quotes without space between quotes). Defaults to \code{" "} (double quotes with space between quotes.
#' 
#' @return A data.table based on \code{target}.
#' 
#' @examples
#' \dontrun{
#' # Load libraries
#' library(data.table)
#' library(Matrix)
#' library(xgboost)
#' 
#' # Create data
#' data(agaricus.train, package = "lightgbm")
#' data(agaricus.test, package = "lightgbm")
#' agaricus_data_train <- data.table(as.matrix(agaricus.train$data))
#' agaricus_data_test <- data.table(as.matrix(agaricus.test$data))
#' agaricus_label_train <- agaricus.train$label
#' agaricus_label_test <- agaricus.test$label
#' folds <- Laurae::kfold(agaricus_label_train, 5)
#' 
#' # Train a model (binary classification)
#' model <- MGScanning(data = agaricus_data_train, # Training data
#'                     labels = agaricus_label_train, # Training labels
#'                     folds = folds, # Folds for cross-validation
#'                     dimensions = 1, # Change this for 2 dimensions if needed
#'                     depth = 10, # Change this to change the sliding window size
#'                     stride = 1, # Change this to change the sliding window speed
#'                     nthread = 1, # Change this to use more threads
#'                     lr = 1, # Do not touch this unless you are expert
#'                     training_start = NULL, # Do not touch this unless you are expert
#'                     validation_start = NULL, # Do not touch this unless you are expert
#'                     n_forest = 2, # Number of forest models
#'                     n_trees = 30, # Number of trees per forest
#'                     random_forest = 1, # We want only 2 random forest
#'                     seed = 0,
#'                     objective = "binary:logistic",
#'                     eval_metric = "logloss",
#'                     multi_class = 2, # Modify this for multiclass problems)
#'                     verbose = TRUE)
#' 
#' # Create predictions
#' data_predictions <- model$preds
#' 
#' # Example on fake pictures (matrices) and multiclass problem
#' 
#' # Generate fake images
#' new_data <- list(matrix(rnorm(n = 400), ncol = 20, nrow = 20),
#'                  matrix(rnorm(n = 400), ncol = 20, nrow = 20),
#'                  matrix(rnorm(n = 400), ncol = 20, nrow = 20),
#'                  matrix(rnorm(n = 400), ncol = 20, nrow = 20),
#'                  matrix(rnorm(n = 400), ncol = 20, nrow = 20),
#'                  matrix(rnorm(n = 400), ncol = 20, nrow = 20),
#'                  matrix(rnorm(n = 400), ncol = 20, nrow = 20),
#'                  matrix(rnorm(n = 400), ncol = 20, nrow = 20),
#'                  matrix(rnorm(n = 400), ncol = 20, nrow = 20),
#'                  matrix(rnorm(n = 400), ncol = 20, nrow = 20))
#' 
#' # Generate fake labels
#' new_labels <- c(2, 1, 0, 2, 1, 0, 2, 1, 0, 0)
#' 
#' # Train a model (multiclass problem)
#' model <- MGScanning(data = new_data, # Training data
#'                     labels = new_labels, # Training labels
#'                     folds = list(1:3, 3:6, 7:10), # Folds for cross-validation
#'                     dimensions = 2,
#'                     depth = 10,
#'                     stride = 1,
#'                     nthread = 1, # Change this to use more threads
#'                     lr = 1, # Do not touch this unless you are expert
#'                     training_start = NULL, # Do not touch this unless you are expert
#'                     validation_start = NULL, # Do not touch this unless you are expert
#'                     n_forest = 2, # Number of forest models
#'                     n_trees = 10, # Number of trees per forest
#'                     random_forest = 1, # We want only 2 random forest
#'                     seed = 0,
#'                     objective = "multi:softprob",
#'                     eval_metric = "mlogloss",
#'                     multi_class = 3, # Modify this for multiclass problems)
#'                     verbose = TRUE)
#' 
#' # Matrix output is 10x600
#' dim(model$preds)
#' }
#' 
#' @export

MGScanning <- function(data,
                       labels,
                       folds,
                       dimensions = 1,
                       depth = 10,
                       stride = 1,
                       nthread = 1,
                       lr = 1,
                       training_start = NULL,
                       validation_start = NULL,
                       n_forest = 2,
                       n_trees = 30,
                       random_forest = 1,
                       seed = 0,
                       objective = "reg:linear",
                       eval_metric = "rmse",
                       multi_class = 2,
                       verbose = TRUE) {
  
  model <- list()
  
  if (dimensions == 1) {
    
    # One-Dimensional Scan
    
    steps_perform <- ceiling((copy(ncol(data)) - depth) / stride)
    step <- 1:depth
    preds <- data.table(ID = 1:nrow(data))
    
    # Slide observations
    for (i in 1:steps_perform) {
      
      # Create training data
      training_data <- Laurae::DTcolsample(data, step)
      
      # Train model
      model[[i]] <- CRTreeForest(training_data = training_data,
                                 validation_data = NULL,
                                 training_labels = labels,
                                 validation_labels = NULL,
                                 folds = folds,
                                 nthread = nthread,
                                 lr = lr,
                                 training_start = training_start,
                                 validation_start = validation_start,
                                 n_forest = n_forest,
                                 n_trees = n_trees,
                                 random_forest = 1,
                                 seed = seed,
                                 objective = objective,
                                 eval_metric = eval_metric,
                                 return_list = FALSE,
                                 multi_class = multi_class,
                                 verbose = ifelse(verbose == TRUE, paste0("Scan ", sprintf(paste0("%0", floor(log10(steps_perform)) + 1, "d"), i), "/", steps_perform, ", "), ""))
      model[[i]]$step <- step
      
      if (multi_class > 2) {
        
        # Multiclass combination
        for (j in 1:(multi_class * n_forest)) {
          preds <- preds[, (paste0("Scan", sprintf(paste0("%0", floor(log10(steps_perform)) + 1, "d"), i), "_Forest", sprintf(paste0("%0", floor(log10(n_forest)) + 1, "d"), ((j - 1) %/% multi_class) + 1), "_Class", sprintf(paste0("%0", floor(log10(multi_class)) + 1, "d"), ((j - 1) %% multi_class) + 1))) := model[[i]]$train_preds[, j, with = FALSE]]
        }
        
      } else {
        
        # Not multiclass combination
        for (j in 1:n_forest) {
          preds <- preds[, (paste0("Scan", sprintf(paste0("%0", floor(log10(steps_perform)) + 1, "d"), i), "_Forest", sprintf(paste0("%0", floor(log10(n_forest)) + 1, "d"), j))) := model[[i]]$train_preds[, j, with = FALSE]]
        }
        
      }
      
      step <- (min(step) + stride):min(max(step) + stride, ncol(data))
      
    }
    
    preds$ID <- NULL
    
    return(list(model = model,
                preds = preds,
                dimensions = dimensions))
    
  } else {
    
    # Two-dimensional Scan
    
    steps_perform <- c(ceiling((copy(nrow(data[[1]])) - depth[1]) / stride[1]), ceiling((copy(ncol(data[[1]])) - depth[length(depth)]) / stride[length(stride)]))
    step <- list(1:depth[1], 1:depth[length(depth)])
    preds <- data.table(ID = 1:length(data))
    
    # Slide vertically
    for (i in 1:steps_perform[1]) {
      
      model[[i]] <- list()
      
      # Reset steps
      step[[2]] <- 1:depth[length(depth)]
      
      # Slide horizontally
      for (j in 1:steps_perform[2]) {
        
        # Create training data
        training_data <- data.table(matrix(unlist(lapply(data, function(x, step) {return(as.numeric(x[step[[1]], step[[2]]]))}, step = step)), ncol = ((max(step[[1]]) - min(step[[1]]) + 1) * (max(step[[2]]) - min(step[[2]]) + 1)), nrow = length(data), byrow = TRUE))
        
        # Train model
        model[[i]][[j]] <- CRTreeForest(training_data = training_data,
                                        validation_data = NULL,
                                        training_labels = labels,
                                        validation_labels = NULL,
                                        folds = folds,
                                        nthread = nthread,
                                        lr = lr,
                                        training_start = training_start,
                                        validation_start = validation_start,
                                        n_forest = n_forest,
                                        n_trees = n_trees,
                                        random_forest = 1,
                                        seed = seed,
                                        objective = objective,
                                        eval_metric = eval_metric,
                                        return_list = FALSE,
                                        multi_class = multi_class,
                                        verbose = ifelse(verbose == TRUE, paste0("Scan x=", sprintf(paste0("%0", floor(log10(steps_perform[1])) + 1, "d"), i), "/", steps_perform[1], ", y=", sprintf(paste0("%0", floor(log10(steps_perform[2])) + 1, "d"), j), "/", steps_perform[2], ", "), ""))
        model[[i]][[j]]$step <- step
        
        if (multi_class > 2) {
          
          # Multiclass combination
          for (k in 1:(multi_class * n_forest)) {
            preds <- preds[, (paste0("Scan_", sprintf(paste0("%0", floor(log10(steps_perform[2])) + 1, "d"), j), "x_", sprintf(paste0("%0", floor(log10(steps_perform[1])) + 1, "d"), i), "y_Class", sprintf(paste0("%0", floor(log10(multi_class)) + 1, "d"), j), "_Forest", sprintf(paste0("%0", floor(log10(n_forest)) + 1, "d"), ((k - 1) %/% multi_class) + 1), "_Class", sprintf(paste0("%0", floor(log10(multi_class)) + 1, "d"), ((k - 1) %% multi_class) + 1))) := model[[i]][[j]]$train_preds[, k, with = FALSE]]
          }
          
        } else {
          
          # Not multiclass combination
          for (k in 1:n_forest) {
            preds <- preds[, (paste0("Scan_", sprintf(paste0("%0", floor(log10(steps_perform[2])) + 1, "d"), j), "x_", sprintf(paste0("%0", floor(log10(steps_perform[1])) + 1, "d"), i), "y_Forest", sprintf(paste0("%0", floor(log10(n_forest)) + 1, "d"), k))) := model[[i]][[j]]$train_preds[, k, with = FALSE]]
          }
          
        }
        
        step[[2]] <- (min(step[[2]]) + stride[length(stride)]):min(max(step[[2]]) + stride[length(stride)], nrow(data[[1]]))
        
      }
      
      step[[1]] <- (min(step[[1]]) + stride[1]):min(max(step[[1]]) + stride[1], ncol(data[[1]]))
        
    }
    
    preds$ID <- NULL
    
    return(list(model = model,
                preds = preds,
                dimensions = dimensions,
                multi_class = multi_class,
                folds = folds))
    
  }
  
}
