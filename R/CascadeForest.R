#' Cascade Forest implementation in R
#'
#' This function attempts to replicate Cascade Forest using xgboost. It performs Complete-Random Tree Forest in a Neural Network directed acrylic graph like in Neural Networks, but only for simple graphs (e.g use previous layer output data for next layer training each time). You can specify your learning objective using \code{objective} and the metric to check for using \code{eval_metric}. You can plug custom objectives instead of the objectives provided by \code{xgboost}.
#' 
#' For implementation details of Cascade Forest / Complete-Random Tree Forest / Multi-Grained Scanning / Deep Forest, check this: \url{https://github.com/Microsoft/LightGBM/issues/331#issuecomment-283942390} by Laurae.
#' 
#' \itemize{
#' \item{Complete-Random Tree Forest = ensemble of Random Trees (number of forests parameter)}
#' \item{Random Tree split = take a random feature each time, grow indefinitely until there are only no more than 10 instances of the same class (or there is only one class at the end) (minimum number of instances parameter)}
#' \item{Random Tree Forest = take only sqrt(number of features) per tree (column sampling by tree parameter)}
#' \item{(NOT IMPLEMENTED AS IT IS XGBOOST USED) Split value used = Gini (but I would say using Information Criterion could be better for random forests) (potentially loss function parameter)}
#' \item{Number of features generated by a level = number of complete-random tree forest * number of classes, in case of regression this would be number of complete-random tree forest}
#' \item{Each Complete-Random Tree Forest is generated using cross-validation (stacking like in Kaggle competitions) and using average when you predict (parameter - input folds)}
#' \item{Each time a Cascade Forest is finished, compare to validation set. If the new Cascade Forest is worse than the previous one, terminate training immediately (bonus: early_stopping_rounds would be able to determine how many bad Cascade Forest needed to stop, and maybe prediction should give us the ability to choose how many forests to use?).}
#' }
#' 
#' @param training_data Type: data.table. The training data. Columns are added during training if \code{low_memory == TRUE}, so you may want to clean it up if you use \code{low_memory == TRUE} and interrupt training.
#' @param validation_data Type: data.table. The validation data to check for metric performance. Set to \code{NULL} if you want to use out of fold validation data instead of a custom validation data set. Columns are added during training if \code{low_memory == TRUE}, so you may want to clean it up if you use \code{low_memory == TRUE} and interrupt training.
#' @param training_labels Type: numeric vector. The training labels.
#' @param validation_labels Type: numeric vector. The validation labels.
#' @param folds Type: list. The folds as list for cross-validation.
#' @param boosting Type: logical. Whether to perform boosting or not for training. It may converge faster, but may overfit faster and therefore needs control via \code{cascade_lr}. Defaults to \code{FALSE}.
#' @param nthread Type: numeric. The number of threads using for multithreading. 1 means singlethread (uses only one core). Higher may mean faster training if the memory overhead is not too large. Defaults to \code{1}.
#' @param cascade_lr Type: numeric vector or numeric. The shrinkage affected to each tree per layer to avoid overfitting, for each layer. You may specify a vector to change the learning rate per layer, such as \code{c(0.4, 0.3, 0.2, 0.1, 0.05)} so you can perform boosting afterwards. Defaults to \code{1}.
#' @param training_start Type: numeric vector. The initial training prediction labels. Set to \code{NULL} if you do not know what you are doing. Defaults to \code{NULL}.
#' @param validation_start Type: numeric vector. The initial validation prediction labels. Set to \code{NULL} if you do not know what you are doing. Defaults to \code{NULL}.
#' @param cascade_forests Type: numeric vector (mandatory). The number of forest models per layer in the architecture to create for the Cascade Forest. Defaults to \code{rep(4, 5)}.
#' @param cascade_trees Type: numeric vector or numeric. The number of trees per forest model per layer in the architecture to create for the Cascade Forest. You may specify a vector to change the learning rate per layer, such as \code{500} so you can perform boosting afterwards. Defaults to \code{1000}.
#' @param cascade_rf Type: numeric vector or numeric. The number of Random Forest model per layer in the architecture to create for the Cascade Forest. You may specify a vector to change the learning rate per layer, such as \code{c(1, 1, 2, 3, 5)} so you can perform boosting afterwards. Defaults to \code{2}.
#' @param cascade_seeds Type: numeric vector or numeric. Random seed for reproducibility per layer. Defaults to \code{0}.
#' @param objective Type: character or function. The function which leads \code{boosting} loss. See \code{xgboost::xgb.train}. Defaults to \code{"reg:linear"}.
#' @param eval_metric Type: character or function. The function which evaluates \code{boosting} loss. See \code{xgboost::xgb.train}. Defaults to \code{"rmse"}.
#' @param multi_class Type: numeric. Defines the number of classes internally for whether you are doing multi class classification or not to use specific routines for multiclass problems when using \code{return_list == FALSE}. Defaults to \code{2}, which is for regression and binary classification.
#' @param early_stopping Type: numeric. Defines how many architecture layers without improvement to require before stopping early (therefore, you must remove 1 to that value - for instance, a stopping of 2 means it will stop after 3 failures to improve). 0 means instantly stop at the first failure for improvement. -1 means no stopping. Requires \code{validation_data} to be able to stop early. Defaults to \code{2}.
#' @param maximize Type: logical. Whether to maximize or not the loss evaluation metric. Defaults to \code{FALSE}.
#' @param verbose Type: logical. Whether to print training evaluation. Defaults to \code{TRUE}.
#' @param low_memory Type: logical. Whether to perform the data.table transformations in place to lower memory usage. Defaults to \code{FALSE}.
#' 
#' @return A data.table based on \code{target}.
#' 
#' @examples
#' \dontrun{
#' # Load libraries
#' library(Matrix)
#' library(xgboost)
#' 
#' # Create data
#' data(agaricus.train, package = "lightgbm")
#' data(agaricus.test, package = "lightgbm")
#' agaricus_data_train <- data.table(as.matrix(agaricus.train$data))
#' agaricus_data_test <- data.table(as.matrix(agaricus.test$data))
#' agaricus_label_train <- agaricus.train$label
#' agaricus_label_test <- agaricus.test$label
#' folds <- Laurae::kfold(agaricus_label_train, 5)
#' 
#' # Train a model (binary classification)
#' model <- CascadeForest(training_data = agaricus_data_train, # Training data
#'                        validation_data = agaricus_data_test, # Validation data
#'                        training_labels = agaricus_label_train, # Training labels
#'                        validation_labels = agaricus_label_test, # Validation labels
#'                        folds = folds, # Folds for cross-validation
#'                        boosting = FALSE, # Do not touch this unless you are expert
#'                        nthread = 1, # Change this to use more threads
#'                        cascade_lr = 1, # Do not touch this unless you are expert
#'                        training_start = NULL, # Do not touch this unless you are expert
#'                        validation_start = NULL, # Do not touch this unless you are expert
#'                        cascade_forests = rep(4, 5), # Number of forest models
#'                        cascade_trees = 1000, # Number of trees per forest
#'                        cascade_rf = 2, # Number of Random Forest in models
#'                        cascade_seeds = 0, # Seed per layer
#'                        objective = "binary:logistic",
#'                        eval_metric = "logloss",
#'                        multi_class = 2, # Modify this for multiclass problems
#'                        early_stopping = 2, # stop after 2 bad combos of forests
#'                        maximize = FALSE, # not a maximization task
#'                        verbose = TRUE, # print information during training
#'                        low_memory = FALSE)
#' 
#' # Attempt to perform fake multiclass problem
#' agaricus_label_train[1:100] <- 2
#' 
#' # Train a model (multiclass classification)
#' model <- CascadeForest(training_data = agaricus_data_train, # Training data
#'                        validation_data = agaricus_data_test, # Validation data
#'                        training_labels = agaricus_label_train, # Training labels
#'                        validation_labels = agaricus_label_test, # Validation labels
#'                        folds = folds, # Folds for cross-validation
#'                        boosting = FALSE, # Do not touch this unless you are expert
#'                        nthread = 1, # Change this to use more threads
#'                        cascade_lr = 1, # Do not touch this unless you are expert
#'                        training_start = NULL, # Do not touch this unless you are expert
#'                        validation_start = NULL, # Do not touch this unless you are expert
#'                        cascade_forests = rep(4, 5), # Number of forest models
#'                        cascade_trees = 1000, # Number of trees per forest
#'                        cascade_rf = 2, # Number of Random Forest in models
#'                        cascade_seeds = 0, # Seed per layer
#'                        objective = "multi:softprob",
#'                        eval_metric = "mlogloss",
#'                        multi_class = 3, # Modify this for multiclass problems
#'                        early_stopping = 2, # stop after 2 bad combos of forests
#'                        maximize = FALSE, # not a maximization task
#'                        verbose = TRUE, # print information during training
#'                        low_memory = FALSE)
#' }
#' 
#' @export

CascadeForest <- function(training_data,
                          validation_data,
                          training_labels,
                          validation_labels,
                          folds,
                          boosting = FALSE,
                          nthread = 1,
                          cascade_lr = 1,
                          training_start = NULL,
                          validation_start = NULL,
                          cascade_forests = rep(4, 5),
                          cascade_trees = 500,
                          cascade_rf = 2,
                          cascade_seeds = 0,
                          objective = "reg:linear",
                          eval_metric = "rmse",
                          multi_class = FALSE,
                          early_stopping = 2,
                          maximize = FALSE,
                          verbose = TRUE,
                          low_memory = FALSE) {
  
  model <- list()
  logger <- list()
  num_layers <- length(cascade_forests) # Define number of layers
  original_cols <- copy(ncol(training_data)) + 1 # Perform deep copy of columns
  patience <- early_stopping + 1 # for early_stopping
  
  # Check whether user has input a vector or a simple numeric for cascade_lr
  if (length(cascade_lr) == 1) {
    cascade_lr <- rep(cascade_lr, num_layers)
  }
  
  # Check whether user has input a vector or a simple numeric for cascade_trees
  if (length(cascade_trees) == 1) {
    cascade_trees <- rep(cascade_trees, num_layers)
  }
  
  # Check whether user has input a vector or a simple numeric for cascade_rf
  if (length(cascade_rf) == 1) {
    cascade_rf <- rep(cascade_rf, num_layers)
  }
  
  # Check whether user has input a vector or a simple numeric for cascade_seeds
  if (length(cascade_seeds) == 1) {
    cascade_seeds <- rep(cascade_seeds, num_layers)
  }
  
  # Are we using the low_memory implementation? (does not copy data.table in place)
  if (low_memory == TRUE) {
    
    # Low-memory training
    
    # Create initial frames
    train_data <- training_data
    valid_data <- validation_data
    
    # Perform architecture training
    for (i in 1:num_layers) {
      
      model[[i]] <- CRTreeForest(training_data = train_data,
                                 validation_data = valid_data,
                                 training_labels = training_labels,
                                 validation_labels = validation_labels,
                                 folds = folds,
                                 nthread = nthread,
                                 lr = cascade_lr[i],
                                 training_start = training_start,
                                 validation_start = validation_start,
                                 n_forest = cascade_forests[i],
                                 n_trees = cascade_trees[i],
                                 random_forest = cascade_rf[i],
                                 seed = cascade_seeds[i],
                                 objective = objective,
                                 eval_metric = eval_metric,
                                 return_list = FALSE,
                                 multi_class = multi_class,
                                 verbose = ifelse(verbose == FALSE, "", paste0("Layer ", sprintf(paste0("%0", floor(log10(num_layers)) + 1, "d"), i), ", ")))
      logger[[i]] <- Laurae::cbindlist(model[[i]]$logger)
      
      # Check for early stopping
      if ((early_stopping > -1) & (i > 1)) {
        
        # Check whether to maximize or not metric
        if (maximize == FALSE) {
          
          # Remove or reset patience
          if (mean(rowMeans(logger[[i]])) >= mean(rowMeans(logger[[i - 1]]))) {
            patience <- patience - 1 - ((patience - 1) == early_stopping)
          } else {
            patience <- early_stopping + 1
          }
          
        } else {
          
          # Remove or reset patience
          if (mean(rowMeans(logger[[i]])) <= mean(rowMeans(logger[[i - 1]]))) {
            patience <- patience - 1 - ((patience - 1) == early_stopping)
          } else {
            patience <- early_stopping + 1
          }
          
        }
        
      }
      
      # Check if it is the last layer
      if ((i == num_layers) | (patience < 0)) {
        
        if (patience < 0) {
          best_iteration <- i - early_stopping - 1
        } else {
          best_iteration <- num_layers
        }
        
        if (multi_class > 2) {
          
          # Prepare for multiclass problems
          train_preds <- data.table(matrix(rep(0, nrow(training_data) * multi_class), nrow = nrow(training_data), ncol = multi_class))
          valid_preds <- data.table(matrix(rep(0, nrow(validation_data) * multi_class), nrow = nrow(validation_data), ncol = multi_class))
          colnames(train_preds) <- paste0("Label_", sprintf(paste0("%0", floor(log10(multi_class)) + 1, "d"), 1:multi_class))
          colnames(valid_preds) <- paste0("Label_", sprintf(paste0("%0", floor(log10(multi_class)) + 1, "d"), 1:multi_class))
          
          for (j in 1:multi_class) {
            train_preds[[j]] <- rowMeans(model[[j]]$train_preds[, (0:(cascade_forests[j] - 1)) * multi_class + j, with = FALSE])
            valid_preds[[j]] <- rowMeans(model[[j]]$valid_preds[, (0:(cascade_forests[j] - 1)) * multi_class + j, with = FALSE])
          }
          
        } else {
          
          # It is the last layer, we can perform aggregation by average
          train_preds <- rowMeans(model[[i]]$train_preds)
          valid_preds <- rowMeans(model[[i]]$valid_preds)
          
        }
        
        # Setup names
        names(model) <- paste0("Layer_", sprintf(paste0("%0", floor(log10(num_layers)) + 1, "d"), 1:i))
        names(logger) <- paste0("Layer_", sprintf(paste0("%0", floor(log10(num_layers)) + 1, "d"), 1:i))
        
        # Restore original data
        DTcolsample(training_data, kept = original_cols:copy(ncol(training_data)), remove = TRUE, low_mem = TRUE)
        
        # Check for validation data
        if (!is.null(validation_data)) {
          
          # Restore original data
          DTcolsample(validation_data, kept = original_cols:copy(ncol(validation_data)), remove = TRUE, low_mem = TRUE)
          
        }
        
        # Return to user
        return(list(model = model,
                    logger = logger,
                    train_preds = train_preds,
                    valid_preds = valid_preds,
                    multi_class = multi_class,
                    folds = folds,
                    best_iteration = best_iteration))
        
      } else {
        
        # Not the last layer, therefore we bind predictions, or overwrite them
        training_data <- Laurae::DTcbind(training_data, model[[i]]$train_preds) # Routine overwrites if column names are identical
        training_start <- if (boosting) {rowMeans(model[[i]]$train_preds)} else {NULL}
        validation_data <- Laurae::DTcbind(validation_data, model[[i]]$valid_data) # Routine overwrites if column names are identical
        validation_start <- if (boosting) {rowMeans(model[[i]]$valid_preds)} else {NULL}
        
      }
      
    }
    
  } else {
    
    # Not low-memory training
    
    # Copy in-place
    train_data <- copy(training_data)
    valid_data <- copy(validation_data)
    
    # Perform architecture training
    for (i in 1:num_layers) {
      
      model[[i]] <- CRTreeForest(training_data = train_data,
                                 validation_data = valid_data,
                                 training_labels = training_labels,
                                 validation_labels = validation_labels,
                                 folds = folds,
                                 nthread = nthread,
                                 lr = cascade_lr[i],
                                 training_start = training_start,
                                 validation_start = validation_start,
                                 n_forest = cascade_forests[i],
                                 n_trees = cascade_trees[i],
                                 random_forest = cascade_rf[i],
                                 seed = cascade_seeds[i],
                                 objective = objective,
                                 eval_metric = eval_metric,
                                 return_list = FALSE,
                                 multi_class = multi_class,
                                 verbose = ifelse(verbose == FALSE, "", paste0("Layer ", sprintf(paste0("%0", floor(log10(num_layers)) + 1, "d"), i), ", ")))
      logger[[i]] <- Laurae::cbindlist(model[[i]]$logger)
      
      # Check for early stopping
      if ((early_stopping > -1) & (i > 1)) {
        
        # Check whether to maximize or not metric
        if (maximize == FALSE) {
          
          # Remove or reset patience
          if (mean(rowMeans(logger[[i]])) >= mean(rowMeans(logger[[i - 1]]))) {
            patience <- patience - 1 - ((patience - 1) == early_stopping)
          } else {
            patience <- early_stopping + 1
          }
          
        } else {
          
          # Remove or reset patience
          if (mean(rowMeans(logger[[i]])) <= mean(rowMeans(logger[[i - 1]]))) {
            patience <- patience - 1 - ((patience - 1) == early_stopping)
          } else {
            patience <- early_stopping + 1
          }
          
        }
        
      }
      
      # Check if it is the last layer
      if ((i == num_layers) | (patience < 0)) {
        
        if (patience < 0) {
          best_iteration <- i - early_stopping - 1
        } else {
          best_iteration <- num_layers
        }
        
        if (multi_class > 2) {
          
          # Prepare for multiclass problems
          train_preds <- data.table(matrix(rep(0, nrow(training_data) * multi_class), nrow = nrow(training_data), ncol = multi_class))
          valid_preds <- data.table(matrix(rep(0, nrow(validation_data) * multi_class), nrow = nrow(validation_data), ncol = multi_class))
          colnames(train_preds) <- paste0("Label_", sprintf(paste0("%0", floor(log10(multi_class)) + 1, "d"), 1:multi_class))
          colnames(valid_preds) <- paste0("Label_", sprintf(paste0("%0", floor(log10(multi_class)) + 1, "d"), 1:multi_class))
          
          for (j in 1:multi_class) {
            train_preds[[j]] <- rowMeans(model[[i]]$train_preds[, (0:(cascade_forests[j] - 1)) * multi_class + j, with = FALSE])
            valid_preds[[j]] <- rowMeans(model[[i]]$valid_preds[, (0:(cascade_forests[j] - 1)) * multi_class + j, with = FALSE])
          }
          
        } else {
          
          # It is the last layer, we can perform aggregation by average
          train_preds <- rowMeans(model[[i]]$train_preds)
          valid_preds <- rowMeans(model[[i]]$valid_preds)
          
        }
        
        # Setup names
        names(model) <- paste0("Layer_", sprintf(paste0("%0", floor(log10(num_layers)) + 1, "d"), 1:i))
        names(logger) <- paste0("Layer_", sprintf(paste0("%0", floor(log10(num_layers)) + 1, "d"), 1:i))
        
        # Return to user
        return(list(model = model,
                    logger = logger,
                    train_preds = train_preds,
                    valid_preds = valid_preds,
                    multi_class = multi_class,
                    folds = folds,
                    best_iteration = best_iteration))
        
      } else {
        
        # Not the last layer, therefore we bind predictions
        train_data <- Laurae::DTcbind(training_data, model[[i]]$train_preds)
        training_start <- if (boosting) {rowMeans(model[[i]]$train_preds)} else {NULL}
        valid_data <- Laurae::DTcbind(validation_data, model[[i]]$valid_data)
        validation_start <- if (boosting) {rowMeans(model[[i]]$valid_preds)} else {NULL}
        
      }
      
    }
    
  }
  
}
