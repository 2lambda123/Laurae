% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interactive.eda_tree.R
\name{interactive.eda_tree}
\alias{interactive.eda_tree}
\title{Interactive Dashboard for the Non-Linear Feature Engineering Assistant}
\usage{
interactive.eda_tree(data, label = "!!!!! SELECT ME !!!!!", ban = NULL,
  antiban = "Yes", type = "auto", split = "information", folds = 5,
  seed = 0, verbose = TRUE, plots = TRUE, max_depth = 4,
  min_split = max(20, nrow(data)/1000), min_bucket = round(min_split/3),
  min_improve = 0.01, competing_splits = 2, surrogate_search = 5,
  surrogate_type = 2, surrogate_style = 0, tree_back = "red",
  gain_back = "red", rules_back = "red", details_back = "red",
  f_back = "red", side_width = 300, tree_height = 580,
  gain_height = 200)
}
\arguments{
\item{data}{Type: name reference to a data.frame (preferred) or data.table. Your data, preferably a data.frame but it "should" also work perfectly with data.table.}

\item{label}{Type: character. The name of the label feature in the data. Defaults to \code{"!!!!! SELECT ME !!!!!"}}

\item{ban}{Type: vector of characters or of numerics The names (or column numbers) of variables to be banned from the decision tree. Defaults to \code{NULL}, which means no variables are banned (all variables are potentially used for the decision tree). Defaults to \code{NULL}.}

\item{antiban}{Type: boolean. Whether banned variable selection should be inverted, which means if \code{"yes"}, the \code{ban} transforms into a selection (which bans all other variables not "banned" initially). Defaults to \code{"yes"}.}

\item{type}{Type: character. The type of problem to solve. Either classification (\code{"class"}), regression (\code{"anova"}), count (\code{"poisson"}), or survival (\code{"exp"}). Defaults to \code{"auto"}, which will attempt to find the base type (classification / regression) of model to create using simple heuristics.}

\item{split}{Type: character. If a classification task has been requested (\code{type = "class"}), then the split must be either set to \code{"gini"} (for Gini index) or \code{"information"} (for Information Gain) as the splitting rule. Defaults to \code{"information"} as it is less biased than \code{"gini"} when it comes to cardinalities.}

\item{folds}{Type: integer or character. The folds to use for cross-validation. If you intend to keep the same folds over and over, it is preferrable to provide your own fold character (use a variable name). A numeric vector matching the length of \code{label} is also valid.}

\item{seed}{Type: integer. The random seed applied to the decision tree and the fold generation (if required).}

\item{verbose}{Type: boolean. Whether to print debug information about the model. For each node, a maximum of \code{competing_splits + surrogate_search} rows will be printed. Defaults to \code{TRUE}.}

\item{plots}{Type: boolean. Whether to plot debug information about the model. If using knitr / Rmarkdown, you will have two plots printed: the complexity plot, and the decision tree. Without knitr / Rmarkdown, make sure you look at both. Defaults to \code{TRUE}.}

\item{max_depth}{Type: numeric. The maximum depth of the decision tree. Do not set to large values if the intent is for analysis. Defaults to \code{3}. Any value greater than \code{30} will cause issues on 32-bit operating systems due to C code.}

\item{min_split}{Type: integer. The minimum number of observations in a node to allow a split to be made. If this number is not reached in a node, the node is kept but any other potential splits are cancelled. Keep it large to avoid overfitting. Defaults to \code{max(20, nrow(data) / 1000)}, which is the maximum between 20 and the 0.1\% of the number of observations.}

\item{min_bucket}{Type: integer. The minimum number of observations in a leaf. If this number is not reached in a leaf, the leaf is destroyed. Defaults to \code{round(min_split/3)}, which means by defaults at least 7 to approximately 0.033\% of the number of observations.}

\item{min_improve}{Type: numeric. The minimum fitting improvement to create a node (complexity parameter in Classification and Regression Trees). For regression, the requirement for a leaf to be created and kept is an R-squared increase by at least \code{min_improve}. For classification, the purity (issued from Gini or Information Gain) must increase by at least \code{min_improve}.}

\item{competing_splits}{Type: numeric. The number of best splitting rules retained per split. When using \code{verbose = TRUE}, each node will have \code{competing_splits} rules printed, if they are adequate enough (instead of only one splitting rule). This allows the user to lookup for more details. Defaults to \code{4}.}

\item{surrogate_search}{Type: numeric. The number of surrogate splits to look for. A greater number means more surrogates will be looked for, but increased computation time is required. They are also printed when \code{verbose = TRUE}. Defaults to \code{5}.}

\item{surrogate_type}{Type: numeric. Controls the surrogate creation, with three possible values. If set to \code{0}, any surrogates with missing values are not used for the tree. If set to \code{1}, when all surrogates are with missing values, they are not used the tree. If set to \code{2}, when all surrogates are not used, the majority rule is used (Breiman tree). Sparse frames should preferably use \code{2}. It is recommended to use \code{2} as it handles better missing values, which is the default. Set to \code{0} if you need to ignore as much as possible missing values.}

\item{surrogate_style}{Type: numeric. Controls the selection of the best surrogate, with two values. If set to \code{1}, any missing values in the surrogate is removed to compute the correctness of the surrogate. If set to \code{0}, it ignores any missing values and takes into account all observations to compute the correctness of the surrogate. Defaults to \code{0}. Set to \code{1} if you need to ignore as much as possible missing values.}

\item{tree_back}{Type: character. A background color character for the tree plot. Defaults to \code{"red"}.}

\item{gain_back}{Type: character. A background color character for the gain plot. Defaults to \code{"red"}.}

\item{rules_back}{Type: character. A background color character for the rules. Defaults to \code{"red"}.}

\item{details_back}{Type: character. A background color character for the details Defaults to \code{"red"}.}

\item{f_back}{Type: character. A background color character for the header. Defaults to \code{"red"}.}

\item{side_width}{Type: numeric. The width of the sidebar containing variable names. Defaults to \code{300}.}

\item{tree_height}{Type: numeric. The maximum height for the tree plot. Defaults to \code{580}, which fits nicely Full HD screens (580 vertical pixels).}

\item{gain_height}{Type: numeric. The maximum height for the gain plot. Defaults to \code{200}, which fits nicely Full HD screens (200 vertical pixels).}
}
\value{
The fitted \code{rpart} model.
}
\description{
This function is a massive helper in feature engineering, supposing your variables are already conditioned well enough for 2-way or deeper interactions and you are looking for non-linear relationships. It uses a decision tree (Classification and Regression Trees), and supports factors, integer, and numeric variables.
}
\details{
To use this function properly, you require to set the \code{max_depth} to a very small value (like \code{3}). This ensures interpretability.

Moreover, if you have a sparse frame (with lot of missing values), it is important to keep an eye at \code{surrogate_type} and \code{surrogate_style} as they will dictate whether a split point will be made depending on the missing values. Default values are made to handle them appropriately. However, if your intent is to penalize missing values (for instance if missing values are anomalies), changing their values respectively to \code{0} and \code{1} is recommended.

The colors (\code{tree_back}, \code{gain_back}, \code{rules_back}, \code{details_back}) allowed are the following:

\describe{
  \item{red}{red color}
  \item{yellow}{yellow color}
  \item{aqua}{aqua color}
  \item{blue}{blue color}
  \item{light-blue}{light-blue color}
  \item{green}{green color}
  \item{navy}{navy color}
  \item{teal}{teal color}
  \item{olive}{olive color}
  \item{lime}{lime color}
  \item{orange}{orange color}
  \item{fuchsia}{fuchsia color}
  \item{purple}{purple color}
  \item{maroon}{maroon color}
  \item{black}{black color}
}

The colors (header: \code{f_back}) allowed are the following:

\describe{
  \item{blue}{blue color}
  \item{black}{black color}
  \item{purple}{purple color}
  \item{green}{green color}
  \item{red}{red color}
  \item{yellow}{yellow color}
}
}
\examples{
\dontrun{
library(shiny)
library(shinydashboard)
library(rpart)
library(rpart.plot)
library(partykit)
library(datasets)
data(faithful)
interactive.eda_tree(data = "faithful",
                     label = "!!!!! SELECT ME !!!!!",
                     ban = NULL,
                     antiban = "Yes",
                     type = "auto",
                     split = "information",
                     folds = 5,
                     seed = 0,
                     verbose = TRUE,
                     plots = TRUE,
                     max_depth = 4,
                     min_split = max(20, nrow(data)/1000),
                     min_bucket = round(min_split/3),
                     min_improve = 0.01,
                     competing_splits = 2,
                     surrogate_search = 5,
                     surrogate_type = 2,
                     surrogate_style = 0,
                     tree_back = "red",
                     gain_back = "red",
                     rules_back = "red",
                     details_back = "red",
                     f_back = "red",
                     side_width = 300,
                     tree_height = 580,
                     gain_height = 200)
}
}

